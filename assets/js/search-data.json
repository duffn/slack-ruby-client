{"0": {
    "doc": "Character Encoding",
    "title": "Character Encoding",
    "content": "Slack expects text to be UTF-8 encoded. If your messages appear with text such as BAD+11 in Slack, check text.encoding and .encode(Encoding::UTF_8) your messages before sending them to Slack. text = 'characters such as \"Ñ\", \"Á\", \"É\"' text.encoding =&gt; #&lt;Encoding:UTF-8&gt; client.chat_postMessage(channel: '#general', text: text, as_user: true) # renders 'characters such as \"Ñ\", \"Á\", \"É\"' in Slack text = text.encode(Encoding::ISO_8859_1) text.encoding # =&gt; #&lt;Encoding:ISO-8859-1&gt; client.chat_postMessage(channel: '#general', text: text, as_user: true) # renders 'characters such as \"BAD+11\", \"\", \"BAD+9\"' in Slack . ",
    "url": "/slack-ruby-client/usage/web_client/character_encoding.html",
    
    "relUrl": "/usage/web_client/character_encoding.html"
  },"1": {
    "doc": "Combining RealTime and Web Clients",
    "title": "Combining RealTime and Web Clients",
    "content": "Since the Web client is used to obtain the RealTime client’s WebSocket URL, you can continue using the Web client in combination with the RealTime client. client = Slack::RealTime::Client.new client.on :message do |data| case data.text when 'bot hi' then client.web_client.chat_postMessage(channel: data.channel, text: \"Hi &lt;@#{data.user}&gt;!\") when /^bot/ then client.web_client.chat_postMessage(channel: data.channel, text: \"Sorry &lt;@#{data.user}&gt;, what?\") end end client.start! . See a fully working example in examples/hi_real_time_and_web. ",
    "url": "/slack-ruby-client/usage/realtime_client/combining_realtime_and_web.html",
    
    "relUrl": "/usage/realtime_client/combining_realtime_and_web.html"
  },"2": {
    "doc": "Combining RealTime and Web Clients",
    "title": "Concurrency",
    "content": "Slack::RealTime::Client needs help from a concurrency library and supports Async. Slack::RealTime.configure do |config| config.concurrency = Slack::RealTime::Concurrency::Async end . Use client.start_async instead of client.start!. A good example of such application is slack-ruby-bot-server. client = Slack::RealTime::Client.new client.start_async . ",
    "url": "/slack-ruby-client/usage/realtime_client/combining_realtime_and_web.html#concurrency",
    
    "relUrl": "/usage/realtime_client/combining_realtime_and_web.html#concurrency"
  },"3": {
    "doc": "Combining RealTime and Web Clients",
    "title": "Async",
    "content": "Add async-websocket to your Gemfile. gem 'async-websocket' . See a fully working example in examples/hi_real_time_async_async. ",
    "url": "/slack-ruby-client/usage/realtime_client/combining_realtime_and_web.html#async",
    
    "relUrl": "/usage/realtime_client/combining_realtime_and_web.html#async"
  },"4": {
    "doc": "Command Line Client",
    "title": "Command Line Client",
    "content": "The slack command-line client returns JSON data from the Slack API. ",
    "url": "/slack-ruby-client/usage/command_line_client.html",
    
    "relUrl": "/usage/command_line_client.html"
  },"5": {
    "doc": "Command Line Client",
    "title": "Authenticate with Slack",
    "content": "$ slack --slack-api-token=[token] auth test {\"ok\":true,\"url\":\"...\",\"team\":\"...\",\"user\":\"...\",\"team_id\":\"...\",\"user_id\":\"...\"} . ",
    "url": "/slack-ruby-client/usage/command_line_client.html#authenticate-with-slack",
    
    "relUrl": "/usage/command_line_client.html#authenticate-with-slack"
  },"6": {
    "doc": "Command Line Client",
    "title": "Send a Message",
    "content": "export SLACK_API_TOKEN=... $ slack chat postMessage --text=\"hello world\" --channel=\"#general\" {\"ok\":true,\"channel\":\"...\",\"ts\":\"...\",\"message\":{\"text\":\"hello world\",\"username\":\"bot\",\"type\":\"message\",\"subtype\":\"bot_message\",\"ts\":\"...\"}} . ",
    "url": "/slack-ruby-client/usage/command_line_client.html#send-a-message",
    
    "relUrl": "/usage/command_line_client.html#send-a-message"
  },"7": {
    "doc": "Command Line Client",
    "title": "Get Channel Info",
    "content": "$ slack conversations info --channel=#general {\"ok\":true,\"channel\":{\"id\":\"C04KB5X4D\",\"name\":\"general\", ...}} . ",
    "url": "/slack-ruby-client/usage/command_line_client.html#get-channel-info",
    
    "relUrl": "/usage/command_line_client.html#get-channel-info"
  },"8": {
    "doc": "Command Line Client",
    "title": "List Users",
    "content": "Combine with jq, a command-line JSON parser. $ slack users list | jq '.members | map({(.id): .name})' [ { \"U04KB5WQR\": \"dblock\" }, { \"U07518DTL\": \"rubybot\" } ] . See slack help for a complete command-line reference. ",
    "url": "/slack-ruby-client/usage/command_line_client.html#list-users",
    
    "relUrl": "/usage/command_line_client.html#list-users"
  },"9": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "You can configure Events support globally. Slack::Events.configure do |config| config.signing_secret = 'secret' end . The following settings are supported. | setting | description | . | signing_secret | Slack signing secret, defaults is ENV['SLACK_SIGNING_SECRET']. | . | signature_expires_in | Signature expiration window in seconds, default is 300. | . ",
    "url": "/slack-ruby-client/usage/events/configuration.html",
    
    "relUrl": "/usage/events/configuration.html"
  },"10": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "You can configure the RealTime client either globally or via the initializer. Slack::RealTime::Client.configure do |config| config.websocket_ping = 42 end . client = Slack::RealTime::Client.new(websocket_ping: 42) . The following settings are supported. | setting | description | . | token | Slack API token. | . | websocket_ping | How long the socket can be idle before sending a ping message to confirm it’s still connected, default is 30. | . | websocket_proxy | Connect via proxy, include :origin and :headers. | . | start_options | Options to pass to rtm.connect, default is { request: { timeout: 180 } }. | . | store_class | Local store class, default is an in-memory Slack::RealTime::Stores::Starter. | . | store_options | Options to initialize the store, default is {}. | . | logger | Optional Logger instance that logs RealTime requests and socket data. | . The RealTime client uses a Web client to obtain the WebSocket URL via rtm.connect. While token and logger options are passed down from the RealTime client, you may also configure Web client options via Slack::Web::Client.configure as described above. See a fully working example in examples/hi_real_time_and_web. ",
    "url": "/slack-ruby-client/usage/realtime_client/configuration.html",
    
    "relUrl": "/usage/realtime_client/configuration.html"
  },"11": {
    "doc": "Configuration",
    "title": "Caveats",
    "content": "websocket_ping . This setting determines how long the socket can be idle before sending a ping message to confirm it’s still connected. It’s important to note that if a ping message was sent and no response was received within the amount of time specified in websocket_ping the client will attempt to reestablish it’s connection to the message server. The ping may take between websocket_ping and websocket_ping * 3/2 seconds to actually trigger when there is no activity on the socket. This is because the timer that checks whether to ping is triggered at every websocket_ping / 2 interval. To disable this feature set websocket_ping to 0. ",
    "url": "/slack-ruby-client/usage/realtime_client/configuration.html#caveats",
    
    "relUrl": "/usage/realtime_client/configuration.html#caveats"
  },"12": {
    "doc": "Configuration",
    "title": "Create a New Bot Integration",
    "content": "To integrate your bot with Slack, you must first create a new Slack App. ",
    "url": "/slack-ruby-client/usage/configuration.html#create-a-new-bot-integration",
    
    "relUrl": "/usage/configuration.html#create-a-new-bot-integration"
  },"13": {
    "doc": "Configuration",
    "title": "OAuth Code Grant",
    "content": "Once created, go to the app’s Basic Info tab and grab the Client ID and Client Secret. You’ll need these in order complete an OAuth code grant flow as described at slack-ruby-bot-server. ",
    "url": "/slack-ruby-client/usage/configuration.html#oauth-code-grant",
    
    "relUrl": "/usage/configuration.html#oauth-code-grant"
  },"14": {
    "doc": "Configuration",
    "title": "Using an API Token",
    "content": "Although OAuth is recommended, you can also generate an API token for your app and use it for some interactions. Slack.configure do |config| config.token = ENV['SLACK_API_TOKEN'] end . This sets a global default token. You can also pass a token into the initializer of both Slack::Web::Client and Slack::RealTime::Client or configure those separately via Slack::Web::Config.configure and Slack::RealTime::Config.configure. The instance token will be used over the client type token over the global default. ",
    "url": "/slack-ruby-client/usage/configuration.html#using-an-api-token",
    
    "relUrl": "/usage/configuration.html#using-an-api-token"
  },"15": {
    "doc": "Configuration",
    "title": "Global Settings",
    "content": "The following global settings are supported via Slack.configure. | setting | description | . | token | Slack API token. | . | logger | An optional logger, defaults to ::Logger.new(STDOUT) at Logger::WARN level. | . ",
    "url": "/slack-ruby-client/usage/configuration.html#global-settings",
    
    "relUrl": "/usage/configuration.html#global-settings"
  },"16": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": " ",
    "url": "/slack-ruby-client/usage/configuration.html",
    
    "relUrl": "/usage/configuration.html"
  },"17": {
    "doc": "Enterprise Support",
    "title": "Enterprise Support",
    "content": "Available as part of the Tidelift Subscription. The maintainers of slack-ruby-client are working with Tidelift to deliver commercial support and maintenance. Save time, reduce risk, and improve code health, while paying the maintainers of slack-ruby-client. Click here for more details. ",
    "url": "/slack-ruby-client/enterprise_support.html",
    
    "relUrl": "/enterprise_support.html"
  },"18": {
    "doc": "Error Handling",
    "title": "Error Handling",
    "content": " ",
    "url": "/slack-ruby-client/usage/web_client/error_handling.html",
    
    "relUrl": "/usage/web_client/error_handling.html"
  },"19": {
    "doc": "Error Handling",
    "title": "Slack Errors",
    "content": "If Slack returns an error for the request, then an error will be raised. The error class is specific to the type of error that Slack returns. For instance if Slack returns account_inactive then the error will be Slack::Web::Api::Errors::AccountInactive. This allows you to handle certain types of errors as needed: . rescue Slack::Web::Api::Errors::AccountInactive =&gt; e # deal with inactive account end . All of these errors inherit from Slack::Web::Api::Errors::SlackError, so you can handle or silence all errors if necessary: . rescue Slack::Web::Api::Errors::SlackError =&gt; e # capture all Slack errors end . If there’s a new error type that is not yet known by this library, then it will raise Slack::Web::Api::Errors::SlackError. (Update the Web API if you find that errors are missing — see CONTRIBUTING.) . In all of these cases the error message contains the error code, which is also accessible with slack_error.error. In case of multiple errors, the error message contains the error codes separated by commas, or they are accessible as an array with slack_error.errors. The original response is also accessible using the response attribute. The response_metadata is accessible with slack_error.response_metadata. ",
    "url": "/slack-ruby-client/usage/web_client/error_handling.html#slack-errors",
    
    "relUrl": "/usage/web_client/error_handling.html#slack-errors"
  },"20": {
    "doc": "Error Handling",
    "title": "Rate Limiting",
    "content": "If you exceed Slack’s rate limits, a Slack::Web::Api::Errors::TooManyRequestsError will be raised instead. (This does not inherit from Slack::Web::Api::Errors::SlackError.) . ",
    "url": "/slack-ruby-client/usage/web_client/error_handling.html#rate-limiting",
    
    "relUrl": "/usage/web_client/error_handling.html#rate-limiting"
  },"21": {
    "doc": "Error Handling",
    "title": "Other Errors",
    "content": "When Slack is temporarily unavailable a subclass of Slack::Web::Api::Errors::ServerError will be raised and the original Faraday::Error will be accesible via exception.cause. (Starting with 0.18.0 this is no longer a subclass of Slack::Web::Api::Errors::SlackError.) . Specifically Slack::Web::Api::Errors::ParsingError will be raised on non-json response (i.e. 200 OK with Slack unavailable HTML page) and Slack::Web::Api::Errors::HttpRequestError subclasses for connection failures (Slack::Web::Api::Errors::TimeoutError for read/open timeouts &amp; Slack::Web::Api::Errors::UnavailableError for 5xx HTTP responses). In any other case, a Faraday::ClientError will be raised. ",
    "url": "/slack-ruby-client/usage/web_client/error_handling.html#other-errors",
    
    "relUrl": "/usage/web_client/error_handling.html#other-errors"
  },"22": {
    "doc": "Events API",
    "title": "Events API",
    "content": "This library provides limited support for the Slack Events API. ",
    "url": "/slack-ruby-client/usage/events/events_api.html",
    
    "relUrl": "/usage/events/events_api.html"
  },"23": {
    "doc": "Examples",
    "title": "Examples",
    "content": "Here are some examples of how to use the web client with the Web API. Test Auth . client = Slack::Web::Client.new client.auth_test . Send Messages . Send messages with chat_PostMessage. client.chat_postMessage(channel: '#general', text: 'Hello World', as_user: true) . See a fully working example in examples/hi_web. List Channels . List channels with conversations_list. channels = client.conversations_list.channels general_channel = channels.detect { |c| c.name == 'general' } . Upload a File . Upload a file with files_upload. client.files_upload( channels: '#general', as_user: true, file: Faraday::UploadIO.new('/path/to/avatar.jpg', 'image/jpeg'), title: 'My Avatar', filename: 'avatar.jpg', initial_comment: 'Attached a selfie.' ) . Get Channel Info . You can use a channel ID or name (prefixed with #) in all functions that take a :channel argument. Lookup by name is not supported by the Slack API and the channels_id method called invokes conversations_list in order to locate the channel ID. This invocation can have a cost if you have many Slack channels. In this scenario, we encourage you to use channel id. client.conversations_info(channel: 'C04KB5X4D') # calls conversations_info . client.conversations_info(channel: '#general') # calls conversations_list followed by conversations_info . Get User Info . You can use a user ID or name (prefixed with @) in all functions that take a :user argument. Lookup by name is not supported by the Slack API and the users_id method called invokes users_list in order to locate the user ID. client.users_info(user: 'U092BDCLV') # calls users_info . client.users_info(user: '@dblock') # calls users_list followed by users_info . Search for a User . Constructs an in-memory index of users and searches it. If you want to use this functionality, add the picky gem to your project’s Gemfile. client.users_search(user: 'dblock') . Other . Refer to the Slack Web API Method Reference for the list of all available functions. ",
    "url": "/slack-ruby-client/usage/web_client/examples.html",
    
    "relUrl": "/usage/web_client/examples.html"
  },"24": {
    "doc": "Home",
    "title": "slack-ruby-client",
    "content": "A Ruby and command-line client for the Slack Web, Real Time Messaging and Event APIs. ",
    "url": "/slack-ruby-client/#slack-ruby-client",
    
    "relUrl": "/#slack-ruby-client"
  },"25": {
    "doc": "Home",
    "title": "Useful to me?",
    "content": ". | This library will let you send messages to Slack via the Web API, send and receive messages via the Real Time Messaging API and facilitate integration with the Events API. | To respond to slash commands, interactive components or events, implement a web application using your favorite web framework and use this library to call the Slack Web API and to verify that events are coming from Slack. | To build a bot using the Real Time Messaging API, use slack-ruby-bot, which uses this library. | To roll out a complete service using the Real Time Messaging API with Slack button integration to multiple teams, check out slack-ruby-bot-server, which is built on top of slack-ruby-bot, which uses this library. | . ",
    "url": "/slack-ruby-client/#useful-to-me",
    
    "relUrl": "/#useful-to-me"
  },"26": {
    "doc": "Home",
    "title": "Stable Release",
    "content": "You’re reading the documentation for the next release of slack-ruby-client. Please see the documentation for the last stable release, v2.1.0 unless you’re integrating with HEAD. | See all tagged versions of this documentation for docs for a specific relase. | See UPGRADING when upgrading from an older version. | . ",
    "url": "/slack-ruby-client/#stable-release",
    
    "relUrl": "/#stable-release"
  },"27": {
    "doc": "Home",
    "title": "Installation",
    "content": "Add to Gemfile. gem 'slack-ruby-client' . If you’re going to be using the RealTime client, add async-websocket. See below for more information about concurrency. gem 'async-websocket', '~&gt; 0.8.0' . Run bundle install. ",
    "url": "/slack-ruby-client/#installation",
    
    "relUrl": "/#installation"
  },"28": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/slack-ruby-client/",
    
    "relUrl": "/"
  },"29": {
    "doc": "Message Parsing",
    "title": "Message Parsing",
    "content": "All text in Slack uses the same system of escaping: chat messages, direct messages, file comments, etc. Use Slack::Messages::Formatting to unescape incoming messages. This comes handy, for example, you want to treat all input to a real time bot as plain text. Slack::Messages::Formatting.unescape('Hello &amp;amp; &amp;lt;world&amp;gt;')) # =&gt; 'Hello &amp; &lt;world&gt;' Slack::Messages::Formatting.unescape('Hey &lt;@U024BE7LH|bob&gt;, did you see my file?')) # =&gt; 'Hey @bob, did you see my file?' Slack::Messages::Formatting.unescape('Hey &lt;@U02BEFY4U&gt;')) # =&gt; 'Hey @U02BEFY4U' Slack::Messages::Formatting.unescape('This message contains a URL &lt;http://foo.com/&gt;')) # =&gt; 'This message contains a URL http://foo.com/' Slack::Messages::Formatting.unescape('So does this one: &lt;http://www.foo.com|www.foo.com&gt;')) # =&gt; 'So does this one: www.foo.com' Slack::Messages::Formatting.unescape('&lt;mailto:bob@example.com|Bob&gt;')) # =&gt; 'Bob' Slack::Messages::Formatting.unescape('Hello &lt;@U123|bob&gt;, say hi to &lt;!everyone&gt; in &lt;#C1234|general&gt;')) # =&gt; 'Hello @bob, say hi to @everyone in #general' Slack::Messages::Formatting.unescape('Hello &lt;@U123|bob&gt; &amp;gt; file.txt')) # =&gt; 'Hello @bob &gt; file.txt' Slack::Messages::Formatting.unescape('“hello”')) # =&gt; '\"hello\"' Slack::Messages::Formatting.unescape('‘hello’')) # =&gt; \"'hello'\" . ",
    "url": "/slack-ruby-client/usage/message_parsing.html",
    
    "relUrl": "/usage/message_parsing.html"
  },"30": {
    "doc": "Options",
    "title": "Options",
    "content": "You can configure the Web client either globally or via the initializer. Slack::Web::Client.configure do |config| config.user_agent = 'Slack Ruby Client/1.0' end . client = Slack::Web::Client.new(user_agent: 'Slack Ruby Client/1.0') . The following settings are supported. | setting | description | . | token | Slack API token. | . | user_agent | User-agent, defaults to Slack Ruby Client/version. | . | proxy | Optional HTTP proxy. | . | ca_path | Optional SSL certificates path. | . | ca_file | Optional SSL certificates file. | . | endpoint | Slack endpoint, default is https://slack.com/api. | . | logger | Optional Logger instance that logs HTTP requests. | . | timeout | Optional open/read timeout in seconds. | . | open_timeout | Optional connection open timeout in seconds. | . | default_page_size | Optional page size for paginated requests, default is 100. | . | default_max_retries | Optional number of retries for paginated requests, default is 100. | . | adapter | Optional HTTP adapter to use, defaults to Faraday.default_adapter. | . You can also pass request options, including timeout and open_timeout into individual calls. client.conversations_list(request: { timeout: 180 }) . You can also control what proxy options are used by modifying the http_proxy environment variable per Net::HTTP’s documentation. Docker on OSX seems to incorrectly set the proxy, causing Faraday::ConnectionFailed, ERROR -- : Failed to open TCP connection to : (getaddrinfo: Name or service not known). You might need to manually unset http_proxy in that case, eg. http_proxy=\"\" bundle exec ruby ./my_bot.rb. ",
    "url": "/slack-ruby-client/usage/web_client/options.html",
    
    "relUrl": "/usage/web_client/options.html"
  },"31": {
    "doc": "Pagination",
    "title": "Pagination",
    "content": "The Web client natively supports cursor pagination for methods that allow it, such as users_list. Supply a block and the client will make repeated requests adjusting the value of cursor with every response. The default limit is set to 100 and can be adjusted via Slack::Web::Client.config.default_page_size or by passing it directly into the API call. all_members = [] client.users_list(presence: true, limit: 10) do |response| all_members.concat(response.members) end all_members # many thousands of team members retrieved 10 at a time . When using cursor pagination the client will automatically pause and then retry the request if it runs into Slack rate limiting. (It will pause according to the Retry-After header in the 429 response before retrying the request.) If it receives too many rate-limited responses in a row it will give up and raise an error. The default number of retries is 100 and can be adjusted via Slack::Web::Client.config.default_max_retries or by passing it directly into the method as max_retries. You can also proactively avoid rate limiting by adding a pause between every paginated request with the sleep_interval parameter, which is given in seconds. all_members = [] client.users_list(presence: true, limit: 10, sleep_interval: 5, max_retries: 20) do |response| # pauses for 5 seconds between each request # gives up after 20 consecutive rate-limited responses all_members.concat(response.members) end all_members # many thousands of team members retrieved 10 at a time . ",
    "url": "/slack-ruby-client/usage/web_client/pagination.html",
    
    "relUrl": "/usage/web_client/pagination.html"
  },"32": {
    "doc": "RealTime Client",
    "title": "RealTime Client",
    "content": "The Real Time Messaging API is a WebSocket-based API that allows you to receive events from Slack in real time and send messages as user. client = Slack::RealTime::Client.new client.on :hello do puts \"Successfully connected, welcome '#{client.self.name}' to the '#{client.team.name}' team at https://#{client.team.domain}.slack.com.\" end client.on :message do |data| case data.text when 'bot hi' then client.message(channel: data.channel, text: \"Hi &lt;@#{data.user}&gt;!\") when /^bot/ then client.message(channel: data.channel, text: \"Sorry &lt;@#{data.user}&gt;, what?\") end end client.on :close do |_data| puts \"Client is about to disconnect\" end client.on :closed do |_data| puts \"Client has disconnected successfully!\" end client.start! . You can send typing indicators with typing. client.typing channel: data.channel . You can send a ping with ping. client.ping . ",
    "url": "/slack-ruby-client/usage/realtime_client/realtime_client.html",
    
    "relUrl": "/usage/realtime_client/realtime_client.html"
  },"33": {
    "doc": "Store",
    "title": "Store",
    "content": "The RealTime client exposes and maintains a local store upon successful connection. Event hooks keep the store’s cached data up-to-date. Tracking with a local store can be disabled with Slack::RealTime::Client.new(store_class: nil). ",
    "url": "/slack-ruby-client/usage/realtime_client/store.html",
    
    "relUrl": "/usage/realtime_client/store.html"
  },"34": {
    "doc": "Store",
    "title": "Slack::RealTime::Stores::Starter",
    "content": "A small store that only caches and tracks data returned in the rtm.connect response. This store provides self and team for accessing the limited data about the authenticated user and its workspace, but does not cache other users or bots, channels, or direct messages. ",
    "url": "/slack-ruby-client/usage/realtime_client/store.html#slackrealtimestoresstarter",
    
    "relUrl": "/usage/realtime_client/store.html#slackrealtimestoresstarter"
  },"35": {
    "doc": "Store",
    "title": "Slack::RealTime::Stores::Store",
    "content": "A more complete store that tracks most changes visible to the authenticated user. You can see all of the cache types in the table below (each is a hash indexed by its objects’ id). | Cache | Description | . | teams | Workspaces (teams). Will likely contain only one team. | . | users | All user objects, including self. | . | bots | All bot users (from Slack Apps and legacy custom integrations). | . | public_channels | Public conversation objects. | . | private_channels | Private conversation and group objects with the authenticated user as a member. | . | ims | Visible im objects, direct message channels with the authenticated user. | . | mpims | Visible mpim objects, multiparty direct message channels that include the authenticated user. | . By default, none of these caches are initialized with data beyond what is returned from rtm.connect, same as Slack::RealTime::Stores::Starter. When configured, this store initializes its caches by making additional calls to Web API methods upon successful connection to the RTM API (i.e. “hello” message). Configure by specifying which caches to fetch: . Slack::RealTime::Client.configure do |config| config.store_class = Slack::RealTime::Stores::Store config.store_options = { caches: %i[teams users public_channels private_channels ims] } end . or with the :all option: . Slack::RealTime::Client.configure do |config| config.store_class = Slack::RealTime::Stores::Store config.store_options = { caches: :all } end . For teams, this makes a single call to team.info, while for users and all conversation-like types, this makes paginated calls to users.list and conversations.list respectively. Only bots requires a separate call for every bot user, so may be slow if your workplace has a lot of bot users. ",
    "url": "/slack-ruby-client/usage/realtime_client/store.html#slackrealtimestoresstore",
    
    "relUrl": "/usage/realtime_client/store.html#slackrealtimestoresstore"
  },"36": {
    "doc": "Usage",
    "title": "Usage",
    "content": " ",
    "url": "/slack-ruby-client/usage/usage.html",
    
    "relUrl": "/usage/usage.html"
  },"37": {
    "doc": "Verifying the Request Signature",
    "title": "Verifying the Request Signature",
    "content": "Slack signs its requests using a secret that’s unique to your app. Verify incoming HTTP requests as follows. slack_request = Slack::Events::Request.new(http_request) slack_request.verify! . To specify secrets on a per-request basis: . Slack::Events::Request.new(http_request, signing_secret: signing_secret, signature_expires_in: signature_expires_in) . The verify! call may raise Slack::Events::Request::MissingSigningSecret, Slack::Events::Request::InvalidSignature or Slack::Events::Request::TimestampExpired errors. ",
    "url": "/slack-ruby-client/usage/events/verifying_the_request_signature.html",
    
    "relUrl": "/usage/events/verifying_the_request_signature.html"
  },"38": {
    "doc": "Versions",
    "title": "Versions",
    "content": "These are the different versions of the documentation for slack-ruby-client. | head | v2.1.0 | . ",
    "url": "/slack-ruby-client/versions.html",
    
    "relUrl": "/versions.html"
  },"39": {
    "doc": "Web Client",
    "title": "Web Client",
    "content": "The Slack Web API allows you to build applications that interact with Slack. ",
    "url": "/slack-ruby-client/usage/web_client/web_client.html",
    
    "relUrl": "/usage/web_client/web_client.html"
  }
}
